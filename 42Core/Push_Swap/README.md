# Push_swap Project

## Table of Contents
1. [Introduction](#introduction)
2. [Features](#features)
3. [Lessons Learned](#lessons-learned)

## Introduction

The **Push_swap** project is part of the 42 curriculum and focuses on creating an efficient sorting algorithm that can sort a list of integers using a limited set of operations. The goal is to implement the sorting algorithm using only **push**, **swap**, and **rotate** operations on two stacks. The project challenges students to think about algorithm efficiency and how to solve problems with strict constraints.

The key objective of this project is to design and implement an optimal algorithm that sorts the numbers in the least number of operations, and to efficiently handle edge cases, such as duplicate numbers, very large lists, and minimal input sizes.

## Features

- **Stack Manipulation**: The project requires implementing and manipulating two stacks using operations like `push`, `swap`, and `rotate` to sort an input list of integers.
- **Sorting Algorithm**: You must create an efficient sorting algorithm that minimizes the number of operations, with the goal of achieving the smallest number of moves to sort the entire list.
- **Optimized Solution**: The project focuses on efficiency, and you must find a solution that handles even large data sets within a reasonable number of operations. A brute-force approach will not be sufficient.
- **Edge Case Handling**: Properly handling edge cases such as empty stacks, already sorted lists, and lists with minimal data (like 1 or 2 elements).
- **Use of Recursion and Iteration**: The project allows you to practice both recursion and iteration when designing and implementing the sorting logic.
- **Time Complexity**: Ensuring that the algorithm runs efficiently with the least number of operations and considering time complexity when designing your solution.

## Lessons Learned

1. **Algorithm Optimization**: A significant takeaway from this project was learning how to analyze and optimize algorithms. I learned how to minimize operations and ensure that my solution handled large inputs efficiently.

2. **Data Structure Knowledge**: The project deepened my understanding of stack-based data structures. I learned how to effectively manipulate stacks and use them for sorting, which is crucial in many real-world applications.

3. **Problem Decomposition**: The project taught me how to break down a problem into smaller, manageable subproblems. Sorting with a limited set of operations required me to think critically about how to structure my approach.

4. **Edge Case Handling**: The project emphasized the importance of testing and handling edge cases. I had to account for all possibilities, including empty lists and already sorted data, ensuring my algorithm was robust in all scenarios.

5. **Efficiency and Time Complexity**: A major focus of the project was reducing the number of operations. I learned to evaluate the time complexity of algorithms and ensure that my solution was optimal for various input sizes.

---

